---
alwaysApply: false
---

# Facet Filter — руководство для ИИ‑агента (обновлено)

Назначение: быстрое погружение в реализацию фасетного фильтра (backend + Twig/Stimulus), точки расширения и актуальные изменения: пользовательские названия (label), порядок сортировки (sort) и ограничение пересчёта словаря по выбранным кодам.

## Архитектура и потоки
- Источники данных:
  - `facet_dictionary` — кеш справочников (атрибуты/опции/цены) по категории.
  - `FacetConfig` — конфигурация отображения фасетов (GLOBAL/CATEGORY).
- Флоу:
  1) Индексация (`FacetIndexer`) обновляет `facet_dictionary` по событиям или вручную.
  2) Витринный эндпоинт `/api/catalog/facets` считает живые counts с учётом выбранных фильтров `f[code]=csv`, и теперь отдаёт `meta` для заголовков и сортировки.
  3) Страница категории рендерится Twig’ом; Stimulus‑контроллер управляет чекбоксами, обновляет URL и реактивно перерисовывает фасеты и грид товаров с сортировкой секций по `sort`.

## БД и сущности
### Таблица `facet_dictionary`
- Поля: `id`, `category_id` (nullable: GLOBAL), `attributes_json`, `options_json`, `price_min`, `price_max`, `updated_at`.
- Содержимое (обновлено):
  - `attributes_json.items[]` = `{ code, name, type, min, max, sort? }`.
  - `options_json[]` = `{ code, name, sort? , values[]: { code, label } }`.
- Поведение (обновлено): `name` и `sort` берутся из `FacetConfig` (поля `label` и `order`) при наличии; иначе `name` — из БД (`attribute.name`/`option.name`), `sort` — отсутствует.

### Сущность `FacetConfig`
- Поля: `scope` ('GLOBAL'|'CATEGORY'), `category`, `attributes[]`, `options[]`, `showZeros`, `collapsedByDefault`, `valuesLimit`, `valuesSort` ('popularity'|'alpha'|'manual').
- Элементы `attributes[]`/`options[]` (обновлено): `{ id?, code, label?, enabled, widget, operator?, order?, bins? }`.
- Репозиторий: `findEffectiveConfigForCategory(int $categoryId)` — CATEGORY override → иначе GLOBAL.

## Индексация (FacetIndexer)
- Метод (обновлено): `reindexCategory(int $categoryId, ?array $attributeCodes = null, ?array $optionCodes = null)`.
  - Фильтр кодов: `null` — «не задан фильтр» (включить все), `[]` — «задан, но пустой» (ничего не включать), массив — включить только указанные коды.
  - Атрибуты: DISTINCT из `product_attribute_assignment` (+min/max для числовых).
  - Опции: DISTINCT из `product_option_value_assignment` (`option_value`), доп. агрегаты при наличии.
  - Цены: `product.effective_price` → `price_min/max`.
- Сохранение (обновлено):
  - В `attributes_json.items[].name` и `options_json[].name` пишется пользовательское `label` из `FacetConfig` (если задано), иначе имя из БД.
  - В `attributes_json.items[].sort` и `options_json[].sort` пишется `order` из `FacetConfig` (если задано).

## Эндпоинты
### Админ (ROLE_ADMIN)
- `GET /api/admin/facets/available?category=<id|null>` — данные из `facet_dictionary` (ETag/Cache-Control).
- `GET /api/admin/facets/config?category=<id|global>` — получение актуальной конфигурации.
- `PUT /api/admin/facets/config` — сохранение; контроллер нормализует элементы `{ id?, code, label?, enabled, widget, operator?, order?, bins? }` и стабильно сортирует по `order`, затем `code`.
- `POST /api/admin/facets/reindex?category=<id|all>` (обновлено) — поддерживает тело запроса:
  ```json
  { "attributes": ["code1", "code2"], "options": ["codeA"] }
  ```
  - Если массивы отсутствуют → считать все коды; если массив пуст → не включать этот тип.

### Витрина (обновлено)
- `GET /api/catalog/facets?category=<id>&f[<code>]=v1,v2`
  - Ответ теперь включает:
  ```json
  {
    "facets": { "diametr": { "type": "attribute", "values": [ ... ] }, ... },
    "meta": {
      "diametr": { "title": "Диаметр, мм", "sort": 10 },
      "color": { "title": "Цвет", "sort": 20 }
    }
  }
  ```
  - Перечень фасетов берётся из `FacetConfig` (enabled=true) или из `facet_dictionary` (fallback). `meta.title`/`meta.sort` строятся по правилам: `label` из конфигурации → имя из БД → код.

## Витрина (Twig/Stimulus)
### Разметка
- `templates/catalog/category/show.html.twig` — контейнер с `data-controller="facets"`, targets для списка фасетов и грида.
- Передача начального состояния (обновлено): `data-initial-facets='{"facets":{...},"meta":{...}}'` для первичного рендера без API‑вызова.

### Контроллер `assets/controllers/facets_controller.js` (обновлено)
- Инициализация: читает выбранные фильтры из URL, рендерит из `data-initial-facets` при наличии.
- Загрузка: `GET /api/catalog/facets` → теперь передаёт `meta` в `renderFacets`.
- Рендер секций: заголовок = `meta[code].title || code`.
- Сортировка секций: по `meta.sort` (возрастающий, `null` в конец), затем по `title`.
- Значения чекбоксов не менялись: опции — по `OptionValue.value`, атрибуты — по `string_value`.

## Админ SPA (UI Facets)
- Страница `assets/admin/views/Facets.vue` (обновлено):
  - Две колонки чекбоксов: опции и атрибуты (из репозиториев), с полями «Название» (`label`) и «Порядок» (`order`).
  - «Сохранить» — пишет `label`/`order` в `FacetConfig`, синхронизируя `enabled` по выбранным.
  - «Перестроить справочники» — отправляет выбранные коды в `POST /api/admin/facets/reindex` (пресчёт только для выбранных).

## Производительность и лимиты
- Индексы на таблицах присвоений и `product_to_category` задействованы.
- Для публичного API лимит значений контролируется `valuesLimit`; сортировка значений по популярности/алфавиту — см. `valuesSort`.

## Чек‑лист
- Backend:
  - При изменении формы `FacetConfig` — нормализовать вход и не допускать хардкодов (см. @hardcoderules.mdc).
  - В `FacetIndexer` учитывать `label`/`order` при выгрузке в `facet_dictionary`.
  - Публичный `/api/catalog/facets` — возвращать `meta` и учитывать `FacetConfig`/fallback словарь.
- Frontend:
  - Stimulus‑контроллер использовать `meta.title` и сортировку по `meta.sort`.
  - На странице админки — сохранять `label` и `order`, пересчитывать только выбранные коды.

## Связанные правила
- @projectrules.mdc
- @hardcoderules.mdc
- @stimulus_policy.mdc
- @paginationapiplatformmapping.mdc
- @doctrine_entities.mdc
- @catalog_js_architecture.mdc
---
alwaysApply: false
---

# Facet Filter — руководство для ИИ‑агента

Назначение: быстрое погружение в реализацию фасетного фильтра (backend + Twig/Stimulus), точки расширения и правила внесения изменений.

## Архитектура и потоки
- Источники данных:
  - `facet_dictionary` (БД) — кеш справочников (атрибуты/опции/цены) по категории.
  - `FacetConfig` (ApiResource) — конфигурация отображения фасетов (GLOBAL/CATEGORY).
- Флоу:
  1) Индексация (`FacetIndexer`) обновляет `facet_dictionary` по событиям (см. подписчик) или вручную.
  2) Витринный эндпоинт `/api/catalog/facets` считает живые counts с учетом выбранных фильтров (`f[code]=csv`). Если нет конфига — перечень фасетов берется из `facet_dictionary` (fallback).
  3) Страница категории рендерится Twig’ом; Stimulus‑контроллер управляет чекбоксами, обновляет URL и реактивно перерисовывает фасеты и грид товаров.

## БД и сущности
### Таблица `facet_dictionary`
- Поля: `id`, `category_id` (nullable: GLOBAL), `attributes_json`, `options_json`, `price_min`, `price_max`, `updated_at`.
- Ограничения/индексы: `UNIQUE(category_id)`, `FK(category_id→category.id)`.
- Содержимое:
  - `attributes_json.items[]` = `{ code, name, type, min, max }` (type: string|int|decimal).
  - `options_json[]` = `{ code, name, values[]: { code, label } }`.

### Сущность `FacetConfig` (`src/Entity/FacetConfig.php`)
- Поля: `scope` ('GLOBAL'|'CATEGORY'), `category`, `attributes[]`, `options[]`, `showZeros`, `collapsedByDefault`, `valuesLimit`, `valuesSort` ('popularity'|'alpha'|'manual').
- Инварианты: 1 GLOBAL, не более одного на категорию.
- Репозиторий: `findEffectiveConfigForCategory(int $categoryId)` (CATEGORY override → иначе GLOBAL).

## Индексация
- Сервис: `src/Service/FacetIndexer.php`
  - `reindexCategory(categoryId)` собирает:
    - Атрибуты: DISTINCT из `ProductAttributeAssignment` (+min/max для числовых).
    - Опции: DISTINCT из `ProductOptionValueAssignment` (значения `OptionValue`), а также min/max для некоторых числовых полей (height/bulbs/area при наличии).
    - Диапазон цен: `Product.effective_price` → `price_min/max`.
  - Сохранение: UPSERT в `facet_dictionary`.
- Триггеры: `src/EventSubscriber/FacetReindexSubscriber.php` (+ `src/Doctrine/Subscriber/FacetDoctrineSubscriber.php`) — дебаунс изменений и пересчет в `kernel.terminate`.

## Эндпоинты
### Админ (ROLE_ADMIN)
- `GET /api/admin/facets/available?category=<id|null>` — отдает данные из `facet_dictionary` (ETag/Cache-Control).
- `GET /api/admin/facets/config?category=<id|global>` — получение актуальной конфигурации.
- `PUT /api/admin/facets/config` — сохранение конфигурации.
- `POST /api/admin/facets/reindex?category=<id|all>` — пересчет словаря.

### Витрина
- `GET /api/catalog/facets?category=<id>&f[<code>]=v1,v2` — живые counts по текущей выборке:
  - Перечень фасетов: из `FacetConfig` (если есть) или из `facet_dictionary` (fallback).
  - Подсчет: SQL `GROUP BY` c динамическими `EXISTS`‑фильтрами, где каждый выбранный код применяется через OR к атрибутам/опциям:
    - Атрибуты — по `attribute.code = :code` и `paa.string_value IN (:values)`.
    - Опции — по `option.code = :code` и `option_value.value IN (:values)`.
  - Цена: всегда включается как `range` (min/max по живым данным).
  - Лимит значений: `app.facets.values_limit_default`.

Конфигурация (DI):
- `app.facets.cache_ttl`: TTL публичного кэша,
- `app.facets.values_limit_default`: лимит значений на фасет.

## Витрина (Twig/Stimulus)
### Разметка (`templates/catalog/category/show.html.twig`)
- Контейнер:
  - `data-controller="facets"` на грид‑контейнере (оборачивает сайдбар и товары).
  - Targets: `data-facets-target="list"` (фасеты), `data-facets-target="products"` (грид товаров).
  - Spinner: `#category-grid-spinner` внутри `products`, абсолютный, с белой подложкой (overlay=true).
  - Передача начального состояния фасетов (чтобы не дергать API на первом рендере):
    - `data-initial-facets='{"facets":{...}}'` на `list` (сформировано в `CatalogCategoryController::show`).

### Контроллер `assets/controllers/facets_controller.js`
- Инициализация:
  - Читает выбранные фильтры из URL (`f[code]=csv`) → `this.selected`.
  - Если есть `data-initial-facets` — рендерит фасеты из него; иначе дергает `/api/catalog/facets`.
- Рендер фасетов:
  - Для каждого значения рисуется checkbox; `value` — человекочитаемый label (ВАЖНО: на бэке фильтрация опций идет по `OptionValue.value`).
  - Disabled для `count=0`.
- Реактивность:
  - При клике по checkbox:
    - Обновляет URL через `history.replaceState` (`category` и `f[...]`).
    - Вызывает `/api/catalog/facets` (показывая spinner), затем догружает HTML сетки `GET /category/{slug}/products?...` и скрывает spinner.
- Параметры запроса:
  - `category=<id>`, `f[<code>]=v1,v2` (значения — labels для опций, string_value для атрибутов).

### Грид товаров
- Маршрут: `GET /category/{slug}/products` — возвращает `_grid.html.twig`.
- Применение фильтров в репозитории: `ProductRepository::findActiveByCategoryWithFacets(...)` — для каждого кода формирует OR‑exists:
  - `attribute.code = :code AND paa.stringValue IN (:values)`
  - ИЛИ `option.code = :code AND optionValue.value IN (:values)`
  - Между разными кодами — AND (пересечение наборов).

## Расширение/изменения
- Добавить числовые диапазоны:
  - В `/api/catalog/facets` и `CatalogCategoryController::show` — добавить ветки для `type=range` с обработкой `min/max` параметров.
  - В репозитории/SQL — подмешать условия по числовым значениям (int/decimal) и/или цене.
- Политика операторов:
  - По умолчанию: внутри одного кода — OR (множественный выбор), между кодами — AND.
  - Для конкретных атрибутов можно включать AND (см. поле `operator` в `FacetConfig`), потребуется доработка сборки SQL.
- Производительность:
  - Индексы уже добавлены: `product_option_value_assignment` (`product_id`, `product_id,option_id`), `product_to_category` (`category_id,product_id`), `product_attribute_assignment` (`string_value`).
  - Следить за параметризацией IN‑массивов (`ArrayParameterType::STRING`).

## Чек‑лист изменений
- Backend:
  - Обновить `FacetConfig`/индексацию/эндпоинты при добавлении нового типа фасета.
  - Держать фильтры на стороне бэка; SPA/Twig — только UI.
- Frontend (Stimulus):
  - Обновлять URL при изменении выбора.
  - Spinner показывать на время `/api/catalog/facets` и скрывать после догрузки `/category/{slug}/products`.
  - Сохранять совместимость: опции фильтруются по label, атрибуты — по stringValue.

## Связанные правила
- @projectrules.mdc
- @hardcoderules.mdc
- @stimulus_policy.mdc
- @paginationapiplatformmapping.mdc
- @doctrine_entities.mdc

## Страница поиска (режим поиска)

Цель: вывести фасетный фильтр с агрегатами поверх результатов полнотекстового поиска и фильтровать найденные товары аналогично странице категории.

### Архитектура
- Источник подмножества: `TNTSearch` → список `ids` по запросу `text`.
- Фасеты: тот же публичный эндпоинт `GET /api/catalog/facets`, расширен параметром `text`.
- Грид: отдельный маршрут `GET /search/products?text=...&f[code]=...` — возвращает HTML `_grid.html.twig`.
- Витринная страница: `GET /search/?text=...` — шаблон `templates/catalog/search/index.html.twig`.

### Бэкенд — агрегаты в режиме поиска
- Контроллер: `src/Controller/Catalog/FacetsController.php`
  - При `category` отсутствует и `text` задан → "search‑mode".
  - Выполняется поиск: `App\Service\Search\ProductSearch::search(text, 5000, 0)` → получаем `ids`.
  - Все запросы подсчёта агрегатов выполняются с условием `p.id IN (:ids)` и без join на категорию.
  - Price‑range считается аналогично по `p.id IN (:ids)`.
  - Перечень кодов фасетов:
    1) Если есть `FacetConfig` (GLOBAL scope) — берём включённые `attributes/options` из конфига.
    2) Иначе используем `facet_dictionary` для `category_id IS NULL` (глобальный словарь).
    3) Если и этого нет — авто‑детект кодов по найденному подмножеству (`DISTINCT a.code` из `product_attribute_assignment` и `DISTINCT o.code` из `product_option_value_assignment`).
  - Фильтры `f[code]=csv` учитываются так же, как на категории: OR внутри кода, AND между кодами (через два EXISTS по атрибутам/опциям), исключая текущий код при расчёте его агрегатов.

### Бэкенд — грид товаров в режиме поиска
- Контроллер: `src/Controller/Catalog/SearchController::products`
  - По `text` получаем `ids` через `ProductSearch` (до 5000).
  - Строим `QB`: `p.status = true AND p.id IN (:ids)`.
  - Применяем те же фасетные фильтры (OR‑EXISTS для атрибутов/опций).
  - Порядок карточек — в порядке релевантности TNTSearch: после загрузки сущностей сортируем по `ids` (или используем SQL `ORDER BY FIELD`).

### Фронтенд — Stimulus (поиск)
- Контроллер: `assets/controllers/facets_controller.js`
  - Для страницы категории формирует query с `category`.
  - Для страницы поиска вместо `category` подставляет `text` из URL (см. `buildQuery()`):
    - `q.text = <URLSearchParams.get('text')>`
  - Эндпоинты берутся из data‑атрибутов на контейнере страницы поиска:
    - `data-facets-facets-url-value="/api/catalog/facets"`
    - `data-facets-products-url-value="/search/products"`
  - Поведение: чтение выбранных `f[...]` из URL, загрузка агрегатов, затем загрузка грида, пересборка URL без удаления `text` (сохраняем параметр запроса).

### Twig — страница поиска
- Шаблон: `templates/catalog/search/index.html.twig`
  - Показывать фасетный фильтр только при `total > 1`.
  - Контейнер:
    - `data-controller="facets"`
    - `data-facets-target="list"` (панель фасетов)
    - `data-facets-target="products"` (контейнер грида)
    - `#category-grid-spinner` — якорь спиннера
  - Форма поиска на странице — сабмит на `route('catalog_search')` с полем `name="text"`.

### Параметры запросов
- `GET /api/catalog/facets?text=<q>&f[code]=v1,v2`
- `GET /search/products?text=<q>&f[code]=v1,v2`

### Производительность и лимиты
- Каталог < 5k: безопасно использовать одиночный IN с до 5000 `ids`.
- При росте — возможно кеширование `ids` по ключу запроса (расширение).

### Чек‑лист
- Без `text` — режим категории (или пустой фильтр), без деградации.
- При одном найденном товаре на странице поиска — фасеты скрыты.
- Порядок товаров сохраняет релевантность TNTSearch.
- Глобальная конфигурация фасетов и/или `facet_dictionary` учитываются; при их отсутствии — авто‑детект кодов по подмножеству.

