### Принял уточнения
- Фильтра по производителю — нет.
- В админке нужна страница настроек фасетного фильтра, где администратор выбирает, какие атрибуты и опции участвуют в фильтре.
- Нужен понятный процесс «переиндексации справочников» (источников данных для этой страницы и/или предкеша значений для фронта).

### Что считаем «справочниками»
- «Доступные для фильтрации сущности» в конкретной категории:
  - список атрибутов, реально встречающихся в товарах категории (с типом значения);
  - список опций и их значений, реально встречающихся в товарах категории;
  - диапазоны для числовых полей (минимумы/максимумы).
- Эти данные нужны в админке для выбора фасетов и на фронте — для UX (например, заранее скрыть пустые группы). Счётчики (counts) для фасетов на витрине считаем «живьём» от текущего набора, как и раньше.

### Админ-настройки фасетов (что делаем)
- Новая сущность конфигурации (через API Platform), например `FacetConfig`:
  - scope: `GLOBAL` или `CATEGORY` (per-category переопределяет global);
  - `category` (nullable для GLOBAL);
  - `attributes`: JSON массив записей `{ code, enabled, widget: 'checkbox'|'range', operator: 'OR'|'AND', order?: number, bins?: number|Array<[min,max]> }`;
  - `options`: JSON массив записей `{ code, enabled, widget: 'checkbox'|'range', order?: number, bins?: ... }`;
  - флаги `showZeros`, `collapsedByDefault`, лимит значений и сортировка значений (`popularity|alpha|manual`).
- Admin SPA (Vue) страница `Каталог → Фасетный фильтр`:
  - Слева выбор категории (или «Глобально»), справа конструктор фасетов.
  - Кнопки: «Сохранить», «Перестроить справочники» (ручной запуск reindex), «Сбросить».
  - Автоподстановка доступных атрибутов/опций на основе справочников (см. ниже).
- API для админки:
  - `GET /api/admin/facets/available?category=<id>` — вернуть доступные атрибуты/опции в категории (из кэша-справочника).
  - `GET /api/admin/facets/config?category=<id|global>` — текущая конфигурация.
  - `PUT /api/admin/facets/config` — сохранить.
  - `POST /api/admin/facets/reindex?category=<id|all>` — ручная переиндексация.

### Переиндексация справочников: как работает
- Вводим таблицу кэша (например, `facet_dictionary`):
  - `id`, `category_id` (nullable для GLOBAL), `attributes_json`, `options_json`, `price_min`, `price_max`, `updated_at`.
  - `attributes_json`: список атрибутов с метаданными (код, имя, тип, min/max для числовых).
  - `options_json`: список опций; для дискретных — перечень `valueCode/valueLabel`, для числовых — `min/max`.
- Сервис `FacetIndexer`:
  - `reindexCategory(int $categoryId)` — собирает:
    - базовый набор товаров категории (активные) → `product_ids`;
    - атрибуты: `SELECT DISTINCT attribute_id, code, name, data_type ...` плюс min/max для `int/decimal`;
    - опции: `SELECT DISTINCT option_id, o.code, o.name ...` плюс `value`-ы (для дискретных) и min/max для `height/bulbsCount/lightingArea`;
    - `price_min/price_max` по `product.effective_price` в категории.
  - `reindexAll()` — по всем категориям (батчево).
- Триггеры переиндексации:
  - Ручной запуск из админки (кнопка).
  - CLI-команда (CRON, ночной пересчёт): `php bin/console app:facet:reindex [--category=ID|--all]`.
  - Автоинвалидация по событиям Doctrine:
    - при изменении `Product`, `ProductToCategory`, `ProductAttributeAssignment`, `ProductOptionValueAssignment`, а также справочников `Attribute/Option/OptionValue`;
    - стратегия «debounce»: складываем «грязные category_id» в in‑memory очередь и пересчитываем через Messenger/дефер (если Messenger не используется — минимальный синхронный пересчёт, но с агрегацией повторов).
- Производительность:
  - <5000 SKU — пересчёт категории: десятки–сотни миллисекунд; по всем категориям — секунды. Легко класть в CRON.
- Кэширование:
  - Храним в `facet_dictionary` + HTTP кеш в админке (ETag/Cache-Control).
  - Инвалидация по изменению источников данных.

### Что меняется на витрине (фронт)
- Эндпоинт фасетов (`GET /api/catalog/facets?...`) остаётся «живой» агрегацией по текущему набору (учитывает выбранные фильтры), но:
  - ограничивает список возвращаемых фасетов тем, что разрешено в `FacetConfig` для категории (или GLOBAL);
  - может использовать `facet_dictionary` для:
    - ранней отбраковки пустых групп;
    - подсказок по диапазонам (мин/макс) до первого запроса.
- В counts — всегда живые `GROUP BY` по текущему набору (кэш короткий, 30–120 сек).

### Индексы для стабильности
```sql
-- Опции (пересечения/агрегации)
CREATE INDEX idx_pova_product         ON product_option_value_assignment (product_id);
CREATE INDEX idx_pova_product_option  ON product_option_value_assignment (product_id, option_id);

-- Категории (если нет)
CREATE INDEX idx_ptc_category_product ON product_to_category (category_id, product_id);

-- Атрибуты (по необходимости для админских списков/поиска)
CREATE INDEX idx_paa_string           ON product_attribute_assignment (string_value);
```

### Поток данных (админка)
1) Админ открывает страницу → `GET /api/admin/facets/available?category=...` (берём из `facet_dictionary`).  
2) Выбирает нужные атрибуты/опции, настраивает виджеты/порядок → `PUT /api/admin/facets/config`.  
3) При массовых изменениях каталога админ жмёт «Перестроить справочники» или ждёт ночной CRON/автоинвалидацию.

### Поток данных (витрина)
1) Рендер категории: параллельно запрашиваем `/api/products?...` и `/api/catalog/facets?...`.  
2) Панель фасетов строится по `FacetConfig`; counts считаются по живому набору.  
3) Пользователь кликает фильтр → обновляем query, повторяем оба запроса.

### Минимальный план внедрения
- БД:
  - миграции индексов (см. SQL выше);
  - таблица `facet_dictionary` (id, category_id, attributes_json, options_json, price_min, price_max, updated_at).
- Бекенд:
  - сущность `FacetConfig` (ApiResource) + репозиторий;
  - сервис `FacetIndexer` + CLI-команда + (по возможности) слушатели Doctrine для инвалидации;
  - контроллеры/провайдеры:
    - `GET /api/admin/facets/available`
    - `POST /api/admin/facets/reindex`
    - `GET/PUT /api/admin/facets/config`
    - (уже обсуждался) `GET /api/catalog/facets` — ограничивает фасеты по конфигу.
- Админ (Vue):
  - новая страница настроек фасетов;
  - сервисы для вызова API; сохранение/загрузка конфигов; кнопка reindex.
- Витрина:
  - использовать конфиг для перечня фасетов; логику подсчётов оставить «живой» с коротким кэшем.

### Ответы на вопросы
- «Подгружать существующие атрибуты и опции» — да, из `facet_dictionary` для выбранной категории (либо global как fallback). Эти данные отражают только реально встречающиеся в товарах категории.
- «Как будет происходить переиндексация справочников?» — через `FacetIndexer`: ручной запуск из админки, CRON-команда и автоинвалидация по событиям Doctrine; результат сохраняется в `facet_dictionary`. На <5000 SKU пересчёт лёгкий и быстрый.

- Если хотите, подготовлю схемы таблиц `facet_dictionary` и `FacetConfig`, а также контракт ответов для админских эндпоинтов.