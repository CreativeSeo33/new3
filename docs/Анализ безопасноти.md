Сделаю быстрый обзор мест, откуда вызывается `checkout-form`, и где обрабатывается `checkout_submit`, чтобы выявить несоответствия и риски. Проверяю шаблоны и код каталога/бэкенда параллельно.

[5 tools called]

Сейчас проверю HTTP‑клиент и CSRF/метод отправки, а также наличие формы/кнопки в шаблонах checkout. Затем сверю id/селекторы формы с компонентом.

[2 tools called]

Соберу ключевые файлы формы, кнопки и CSRF, чтобы точно сверить селекторы, имена полей и защиту.

[10 tools called]

Сейчас просмотрю модуль выбора доставки, чтобы проверить, как он сохраняет DeliveryContext и синхронизирован ли он с оформлением.

[1 tool called]

Сделаю проверку: валидируется ли заголовок `X-CSRF-Token` на сервере, и каковы ограничения CORS/безопасности.

[1 tool called]

Сейчас проверю, валидируется ли CSRF-токен на сервере (по использованию CsrfTokenManagerInterface / CsrfTokenValidator). Затем посмотрю CORS/security пакеты.

[6 tools called]

### Вывод сразу
- **CSRF не проверяется на сервере**: фронт шлёт заголовок `X-CSRF-Token`, но бэкенд его не валидирует. Это реальная уязвимость CSRF для `POST /checkout`.
- **Кнопка сабмита вне формы → HTML5‑валидация не срабатывает**: кнопка не привязана к `form`, и компонент ловит клик, а не `submit`. Поля с `required` не валидируются браузером.
- **Несоответствие ID сумм в UI**: JS обновляет `#checkout-total`, которого нет в шаблоне (есть `#cart-total`). Часть сумм меняется в одном месте (`#ship-cost`), а итог — в другом (aside).
- **Непредсказуемость ответа при пустой корзине**: сервер делает `redirectToRoute('cart_page')` (HTML), фронт ждёт JSON; в итоге редирект на `/` по дефолту.
- **PII в localStorage**: имя/телефон/email кэшируются в `localStorage` без TTL. Риск при XSS/общем устройстве.

Ниже — доказательства (цитаты) и точечные правки.

### Доказательства (файлы/фрагменты)

- Точка входа и URL сабмита:
```7:7:templates/catalog/checkout/index.html.twig
  <div class="container mx-auto px-4 py-6" data-module="checkout-form" data-submit-url="{{ path('checkout_submit') }}" data-testid="checkout-root">
```

- Форма и кнопка: кнопка вне `<form>` и без привязки к `form="checkout-form"`
```4:27:templates/components/checkout/contact-form.html.twig
  <form id="checkout-form" class="space-y-4">
    ...
  </form>
```
```2:4:templates/components/checkout/submit-button.html.twig
<button id="place-order" class="mt-4 w-full bg-black text-white rounded py-2 disabled:opacity-50" {{ disabled ? 'disabled' }}>
  Подтвердить заказ
</button>
```

- Компонент ловит клик по кнопке (не submit), обходит валидацию формы:
```14:32:assets/catalog/src/features/checkout-form/ui/component.ts
  init(): void {
    this.form = this.$('form#checkout-form');
    this.submitButton = this.$('button#place-order') as HTMLButtonElement | null;
    ...
    if (this.submitButton) {
      this.submitButton.addEventListener('click', this.handleSubmitClick);
    }
  }
```

- Клиент добавляет `X-CSRF-Token`, но сервер его нигде не проверяет:
```22:31:assets/catalog/src/shared/api/http.ts
  if (requiresCsrfToken(method)) {
    try {
      const csrfToken = await getCsrfToken();
      finalHeaders['X-CSRF-Token'] = csrfToken;
    } catch (error) {
      throw new Error('Unable to obtain CSRF token for secure request');
    }
  }
```
```15:26:src/Controller/Api/CsrfController.php
    #[Route('/csrf', name: 'api_csrf_token', methods: ['GET'])]
    public function token(Request $request, CsrfTokenManagerInterface $tokens): JsonResponse
```
```91:118:src/Controller/Catalog/CheckoutController.php
#[Route('/checkout', name: 'checkout_submit', methods: ['POST'])]
public function submit(
  Request $request,
  ...
): Response {
  ...
  $payload = json_decode($request->getContent() ?: '[]', true);
  $name = trim((string)($payload['firstName'] ?? ''));
  ...
  if ($name === '' || $phone === '' || ($email !== '' && !filter_var($email, FILTER_VALIDATE_EMAIL))) {
    return $this->json(['error' => 'Проверьте корректность данных'], 400);
  }
```
(Здесь нет проверки токена из заголовка.)

- Несоответствие итогов: JS ищет `#checkout-total` (нет в шаблоне) и отдельно меняет `#ship-cost`, в сайдбаре используются другие ID.
```38:41:assets/catalog/src/features/delivery-selector/ui/component.ts
    this.shipCostEl = this.$('#ship-cost');
    this.totalEl = document.getElementById('checkout-total');
```
```36:39:templates/catalog/_delivery_selector.html.twig
  <div class="text-sm mt-3">Стоимость доставки: <span id="ship-cost" data-testid="delivery-ship-cost">{{ (delivery.cost is defined and delivery.cost is not null) ? (delivery.cost / 100) : 0 }}</span> ₽</div>
```
```9:17:templates/components/cart/summary.html.twig
  Итого: <span id="cart-total" data-cart-total data-testid="total">{{ (cart.subtotal + delivery.cost)|number_format(0, '.', ' ') ~ ' руб.' }}</span>
```

- Поведение при пустой корзине — редирект (HTML), а фронт ждёт JSON:
```104:106:src/Controller/Catalog/CheckoutController.php
if ($cart->getItems()->count() === 0) {
  return $this->redirectToRoute('cart_page');
}
```

### Конкретные правки

- Безопасность: валидация CSRF в `CheckoutController::submit` (минимальная вставка).
```php
use Symfony\Component\Security\Csrf\CsrfToken;
use Symfony\Component\Security\Csrf\CsrfTokenManagerInterface;

// сигнатуру дополняем $csrf
public function submit(
  Request $request,
  CartManager $cartManager,
  CheckoutContext $checkout,
  OrderRepository $orders,
  EntityManagerInterface $em,
  DeliveryService $deliveryService,
  DeliveryContext $deliveryContext,
  CsrfTokenManagerInterface $csrf
): Response {
  $header = (string)$request->headers->get('X-CSRF-Token', '');
  if ($header === '' || !$csrf->isTokenValid(new CsrfToken('api', $header))) {
    return $this->json(['error' => 'Invalid CSRF token'], 419);
  }
  // ... дальше как было
}
```

- Валидация формы: привязать кнопку к форме и ловить submit.
  - `templates/components/checkout/submit-button.html.twig`:
```2:4:templates/components/checkout/submit-button.html.twig
<button id="place-order" form="checkout-form" type="submit" class="mt-4 w-full bg-black text-white rounded py-2 disabled:opacity-50" {{ disabled ? 'disabled' }}>
  Подтвердить заказ
</button>
```
  - `assets/catalog/src/features/checkout-form/ui/component.ts` (заменить клик на submit + HTML5‑валидация):
```typescript
// init():
if (this.form) {
  this.on('input', () => this.writeCache(this.collectForm()));
  this.on('change', () => this.writeCache(this.collectForm()));
  this.form.addEventListener('submit', this.handleSubmit as EventListener);
}
if (this.submitButton) {
  // убрать click‑листенер
}

// добавить метод:
private handleSubmit = async (e: Event): Promise<void> => {
  e.preventDefault();
  if (!(this.form instanceof HTMLFormElement)) return;

  // HTML5 проверки
  if (!this.form.checkValidity()) {
    this.form.reportValidity();
    return;
  }

  const submitUrl = this.el.dataset.submitUrl || '';
  if (!submitUrl) return;

  const payload = this.collectForm();
  if (this.submitButton) this.submitButton.disabled = true;
  try {
    const res = await submitCheckout(submitUrl, payload);
    try { localStorage.removeItem(this.storageKey); } catch {}
    const redirectUrl = res?.redirectUrl || '/';
    window.location.href = redirectUrl;
  } catch (e: any) {
    if (this.options?.showAlerts !== false) {
      const message = e instanceof Error ? e.message : 'Не удалось оформить заказ';
      alert(message);
    }
  } finally {
    if (this.submitButton) this.submitButton.disabled = false;
  }
};

// destroy():
if (this.form) this.form.removeEventListener('submit', this.handleSubmit as EventListener);
```

- Итоги/стоимость: синхронизировать ID, чтобы обновлялись реальные элементы сайдбара. В `delivery-selector` лучше целиться в `[data-cart-shipping]` и `[data-cart-total]` (fallback на локальные):
```typescript
// cacheDom():
this.shipCostEl = document.querySelector('[data-cart-shipping]') || this.$('#ship-cost');
this.totalEl = document.querySelector('[data-cart-total]') as HTMLElement | null;

// при обновлениях:
if (this.shipCostEl) this.shipCostEl.textContent = (data.shippingCost / 100).toFixed(2) + ' руб.';
if (this.totalEl) this.totalEl.textContent = (data.total / 100).toFixed(2) + ' руб.';
```
Альтернатива — добавить в сайдбар ещё `id="checkout-total"` и перестать дублировать «ship-cost» в двух местах.

- Пустая корзина: отдавать JSON, а не HTML‑редирект:
```php
if ($cart->getItems()->count() === 0) {
  return $this->json(['error' => 'Cart is empty'], 409);
}
```
И в компоненте показать алерт при 409 (уже будет поймано как ошибка). Опционально — при 409 делать `window.location.href = '{{ path('cart_page') }}'`.

- PII‑кэш: минимальный хардненинг — сменить на `sessionStorage` (данные стираются при закрытии вкладки):
```typescript
private readCache(): Record<string, any> {
  try { return JSON.parse(sessionStorage.getItem(this.storageKey) || '{}'); } catch { return {}; }
}
private writeCache(data: Record<string, any>): void {
  try { sessionStorage.setItem(this.storageKey, JSON.stringify(data)); } catch {}
}
```
Если нужно сохранить межсессионно — оставить `localStorage`, но добавить TTL и очистку по истечении.

### Дополнительные замечания
- Бэкенд валидация слабая: нет лимита длины `comment`, нет нормализации телефона. Желательно: ограничить `comment` (например, 1–1000), убрать управляющие символы, нормализовать телефон (либо отклонять не E.164).
- Консистентность валюты: шаблоны показывают «руб.», JS — «₽» и иногда без суффикса. Привести к одному формату (желательно через `formatPrice`).

### Короткий план правок (минимум, безопасно)
- Добавить CSRF‑проверку в `CheckoutController::submit`.
- Привязать кнопку к форме и перейти на `submit`‑событие + `reportValidity()`.
- Выправить селекторы сумм (либо добавить `#checkout-total`, либо обновлять `[data-cart-total]`).
- Возвращать JSON 409 при пустой корзине.
- По желанию — `sessionStorage` для формы.

- В `docs/` готов краткий чек‑лист для PR? Могу добавить `docs/checkout-hardening.md` с точными диффами — скажи, добавлю.