С учётом новых требований — у каждого магазина своя БД (с возможными отличиями схемы) и хостинг — рекомендую идти по пути «Вариант 1: Простые шаблоны» (отдельные приложения + общий `core` как Composer‑пакет). Система тем в одном приложении резко усложнится: придётся переключать соединения/схемы на рантайме, разводить миграции и секреты по тенантам, тащить кросс‑хостинговые подключения — это высокий операционный и архитектурный риск.

Ниже — как грамотно реализовать «Простые шаблоны» с учётом различий в БД, и сравнение с темами в вашем сценарии.

Что менять в архитектуре «Простых шаблонов»
- Monorepo: держите `ecommerce-core` и магазины рядом, чтобы упростить обновления и CI‑матрицу.
- `core` не должен жестко диктовать структуру таблиц. Вынесите общие доменные контракты и логику в интерфейсы/сервисы, а конкретные ORM‑маппинги оставьте магазинным приложениям.

Способы поддержать отличия схемы БД
Выберите один или комбинируйте:

1) MappedSuperclass в core + конкретные Entities в магазинах
- В `core` объявляете `@ORM\MappedSuperclass` с общими полями (без `@ORM\Table`).
- В магазине создаёте `Product` с `@ORM\Entity`/`@ORM\Table`, расширяющий базу и добавляющий свои поля.

Пример:

```php
// ecommerce-core/src/Entity/BaseProduct.php
namespace App\Core\Entity;

use Doctrine\ORM\Mapping as ORM;

#[ORM\MappedSuperclass]
abstract class BaseProduct
{
    #[ORM\Id]
    #[ORM\GeneratedValue]
    #[ORM\Column]
    protected ?int $id = null;

    #[ORM\Column(length: 255)]
    protected string $name;

    #[ORM\Column(type: 'decimal', precision: 10, scale: 2)]
    protected string $price;
    // getters/setters...
}
```

```php
// shop-electronics/src/Entity/Product.php
namespace App\Entity;

use App\Core\Entity\BaseProduct;
use Doctrine\ORM\Mapping as ORM;

#[ORM\Entity(repositoryClass: ProductRepository::class)]
#[ORM\Table(name: 'products')]
class Product extends BaseProduct
{
    #[ORM\Column(length: 255, nullable: true)]
    private ?string $brand = null;

    #[ORM\Column(type: 'json', nullable: true)]
    private ?array $specifications = null;
    // getters/setters...
}
```

Плюсы: гибкость схем, Doctrine живёт в магазине. Минусы: сервисы `core` не могут ссылаться на конкретные entities — им нужны абстракции.

2) Репозитории как интерфейсы в core, реализации — в магазинах
- В `core` определяете `ProductRepositoryInterface` и сервисы, которые на него зависят.
- В магазине реализуете `DoctrineProductRepository` под свою схему.

Пример:

```php
// ecommerce-core/src/Repository/ProductRepositoryInterface.php
namespace App\Core\Repository;

use App\Core\Model\ProductView;

interface ProductRepositoryInterface
{
    public function findById(int $id): ?ProductView;
    public function search(string $q, array $filters = []): array;
}
```

```php
// shop-electronics/src/Repository/DoctrineProductRepository.php
namespace App\Repository;

use App\Core\Repository\ProductRepositoryInterface;
use App\Core\Model\ProductView;
use Doctrine\ORM\EntityManagerInterface;

class DoctrineProductRepository implements ProductRepositoryInterface
{
    public function __construct(private EntityManagerInterface $em) {}

    public function findById(int $id): ?ProductView
    {
        $p = $this->em->getRepository(Product::class)->find($id);
        return $p ? ProductView::fromEntity($p) : null;
    }
}
```

```yaml
# shop-electronics/config/services.yaml
App\Core\Repository\ProductRepositoryInterface: '@App\Repository\DoctrineProductRepository'
```

Плюсы: `core` не знает про ORM и схему, только про контракт и DTO. Минусы: больше кода адаптеров.

3) DB views как «нормализация»
- Если отличия небольшие, в магазине добавляете `VIEW core_product(...) AS SELECT ... FROM products_shop`.
- В `core` фиксируете entity на `core_product`. Каждый магазин создаёт свою view, подгоняя имена/типы.

Плюсы: `core` может иметь готовые Doctrine entities. Минусы: требует дисциплины в миграциях, ограничивает сложные различия.

4) JSON/Property bag для нестандартных атрибутов
- Общие поля — столбцы, дополнительное — `attributes JSON`. Магазин парсит и рендерит свои поля.
- Хорошо работает для «небольших отличий», быстро, но есть компромисс в типизации и индексации.

Как разместить логику между core и магазинами
- В `core`:
  - Доменные интерфейсы (`ProductRepositoryInterface`, `CategoryRepositoryInterface`).
  - Сервисы (`ProductSearchService`, `OrderProcessor`) — работают с интерфейсами и возвращают DTO (`ProductView`, `CategoryView`).
  - Общие контроллеры можно оставить, если они не упираются в специфичные поля. Иначе — контроллеры в магазинах.

- В магазине:
  - ORM‑entities и реальные репозитории.
  - Шаблоны/ассеты полностью свои.
  - Переопределения контроллеров при необходимости (главная, маркетинговые страницы).

Doctrine и миграции
- Миграции ведёт магазин: свой `migrations/`, свой `doctrine.yaml`.
- Если хотите частично унифицировать, давайте `core` «базовые» миграции в отдельной директории и подключайте их вторым путём:
  - В магазине укажите два пути: `vendor/yourvendor/ecommerce-core/migrations` и `migrations`.
  - Но из-за отличий схемы это часто лишнее — проще держать миграции только в магазинах.
- Контрактные тесты в `core`: прогоняются в каждом магазине, проверяют, что `ProductRepositoryInterface` и сервисы возвращают корректные данные (DTO заполнены). Это ваша страховка от рассинхронизации схемы.

Деплой и хостинг
- Каждый магазин — свой пайплайн, свой `.env`, своё логирование/метрики, своя БД.
- Core обновляется через `composer update yourvendor/ecommerce-core` + тесты, затем деплой.
- CI‑матрица: шаги обновления core в `shop-*` и запуск контрактных тестов.

Повторное использование UI
- Библиотеку Twig‑макросов и компоненты можно держать в `core/templates` и подключать как `twig.paths` (неймспейс `CoreTemplates`). Магазин может переопределять, а где удобно — использовать `include '@CoreTemplates/...'`.
- Если фронт сильно разный, UI держите в магазине, а в `core` — только бизнес‑шаблоны для fallback.

Почему «Система тем» хуже под ваши условия
- Разные БД и хостинги → в одном приложении придётся:
  - управлять множеством соединений/секретов по тенантам,
  - делать маршрутизацию к нужной БД на каждом запросе,
  - поддерживать пер‑тенант миграции и жизненный цикл,
  - решать сетевые задержки к удалённым БД (разные хостинги),
  - бороться с кэшированием/изоляцией, логами, ограничениями хостинга.
- Отличия схем → общий `Doctrine`‑маппинг для всех тенантов ломается. Понадобятся пер‑тенант entities/метаданные и мульти‑EM. Это сильно сложнее, чем отдельные приложения.

Практическая дорожная карта
1) Завести `ecommerce-core` с:
   - интерфейсами репозиториев,
   - сервисами, работающими через контракты, возвращающими DTO,
   - общими полезными Twig‑компонентами (опционально).
2) Развернуть первый магазин как отдельный Symfony‑app:
   - реализовать entities/репозитории под свою схему,
   - настроить `twig.paths` на `core/templates` как fallback,
   - уникальные шаблоны, стили, ассеты, конфиги.
3) Контрактные тесты:
   - в `core` — тесты сервисов против mock‑репозиториев,
   - в магазине — адаптер‑тесты, что реализация интерфейса проходит тест‑набор `core`.
4) CI/CD:
   - матрица обновлений `core` по магазинам,
   - деплой каждого магазина отдельно.
5) Выбрать стратегию для «небольших отличий» в таблицах:
   - если реально малы — DB views или JSON‑атрибут;
   - если отличаются ощутимо — `MappedSuperclass` + свои entities.

Итог
- С вашими требованиями изоляции БД и хостинга — делайте отдельные приложения с общим `core`. Это проще, надёжнее и безопаснее.
- В `core` оставляйте контракты и бизнес‑сервисы; в магазинах — ORM и представление.
- Если появится магазин, почти не отличающийся по схеме и инфраструктуре, его можно держать как отдельный app с минимальным усилием. Система тем хороша для одного инстанса и общих БД — это не ваш случай.