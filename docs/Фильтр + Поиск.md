Короткий ответ
- Вам не нужен отдельный «фильтр по агрегациям». Держите единый эндпоинт фасетов (`GET /api/catalog/facets?...`) и просто учитывайте `q` (поисковый запрос) в базовом наборе данных, от которого считаются counts.
- На вашем масштабе (<5000 товаров) наиболее совместим и простой — «MySQL FULLTEXT + лемматизация в приложении» (один движок для всего: и поиск, и фасеты/агрегации).
- Если всё‑таки выбираете внешний движок: 
  - с TNTSearch агрегации всё равно считаются в MySQL по списку найденных `product_id` (материализованному набору);
  - с Manticore/Elasticsearch агрегации удобнее считать прямо в поисковом движке (FACET/aggregations), что даёт идеальную совместимость по релевантности/фильтрам.

Ниже — сравнительный разбор именно с точки зрения совместимости с вашим фасетным фильтром и «живыми» агрегациями.

1) MySQL FULLTEXT + лемматизация/стемминг в приложении (рекомендуется)
Суть:
- Храним нормализованные леммы/стемы в отдельных колонках (`name_lemmas`, `description_lemmas`, `search_lemmas`), `FULLTEXT` индексы по ним.
- Поиск: `MATCH() AGAINST()` в `BOOLEAN MODE` по леммам.
- Фасеты/агрегации: обычные `GROUP BY` в MySQL по таблицам назначений атрибутов/опций с учётом «базового набора» (поисковая выборка + выбранные фильтры).

Инструменты:
- `phpmorphy` или `wamania/php-stemmer` для нормализации запроса и полей.
- Doctrine + кастомный провайдер/репозиторий.
- Ваши текущие таблицы (`product_attribute_assignment`, `product_option_value_assignment`) + индексы (как в вашем `Фильтр.md`).

Как считать counts с учётом `q` и выбранных фильтров:
- Формируете «базовый набор» как CTE/подзапрос, который учитывает:
  - категорию,
  - активность товара,
  - поисковую часть (`MATCH(search_lemmas) AGAINST (:q IN BOOLEAN MODE)`),
  - уже выбранные пользователем фильтры (кроме измерения, для которого сейчас считаем counts — self-exclusion).
- Далее для каждого фасета выполняете простой `GROUP BY` поверх базового набора.

Пример (упрощённо, опции/их значения):
```sql
WITH base AS (
  SELECT p.id
  FROM product p
  JOIN product_to_category pc ON pc.product_id = p.id AND pc.category_id = :categoryId
  WHERE p.active = 1
    AND MATCH(p.search_lemmas) AGAINST (:q IN BOOLEAN MODE)
    -- здесь же применяете уже выбранные фильтры пользователя, КРОМЕ текущей группы фасета
)
SELECT a.option_id, a.value_id, COUNT(*) AS cnt
FROM base b
JOIN product_option_value_assignment a ON a.product_id = b.id
GROUP BY a.option_id, a.value_id;
```

Числовые диапазоны (histogram/bins) из `FacetConfig`:
- Либо бины на стороне приложения (генерируете `CASE WHEN`):
```sql
SELECT
  SUM(CASE WHEN pa.decimal_value BETWEEN :b0_min AND :b0_max THEN 1 ELSE 0 END) AS bin0,
  SUM(CASE WHEN pa.decimal_value BETWEEN :b1_min AND :b1_max THEN 1 ELSE 0 END) AS bin1,
  ...
FROM base b
JOIN product_attribute_assignment pa ON pa.product_id = b.id AND pa.attribute_id = :attrId;
```
- Либо считать min/max из `facet_dictionary` для подсказки, а counts — как выше.

Плюсы:
- Единый движок и для поиска, и для агрегаций. Никакой «склейки» источников.
- Простые, предсказуемые SQL. На 5k SKU всё мгновенно.
- Полный контроль соответствия базового набора выдачи и подсчёта counts (одни и те же WHERE).

Минусы:
- Нужно поддерживать лемматизацию/стемминг в приложении.
- Релевантность MySQL ограничена по сравнению с специализированными движками, но для 5k — обычно достаточно.

Лучше всего подходит:
- Ваш текущий дизайн «живых» агрегаций, «справочники» в БД, короткий кэш — полностью совместим. Ничего не дублируется и не рассинхронизируется.

2) TNTSearch (внешний PHP‑движок, без сервиса)
Суть:
- Поиск и релевантность — TNTSearch (русский стеммер), индекс в файлах.
- Фасеты/агрегации — в MySQL, но по множеству `product_id`, найденных TNTSearch.

Инструменты:
- `teamtnt/tntsearch` (+ `wamania/php-stemmer` внутри).
- Doctrine для агрегаций.
- Опционально: временная таблица для ID.

Как считать counts:
- Выполнить поиск в TNTSearch и получить все совпадающие `product_id` (не только top N).
- Материализовать набор ID:
  - `CREATE TEMPORARY TABLE tmp_search_ids (id BIGINT PRIMARY KEY) ENGINE=Memory;`
  - батчево `INSERT` ids.
- Дальше агрегации — как в подходе 1, но добавляете `JOIN tmp_search_ids t ON t.id = p.id` в CTE `base`.

Плюсы:
- Отличная релевантность/скорость без внешнего сервиса.
- Совместим с текущим «живым» подсчётом фасетов через MySQL.

Минусы:
- Нужно уметь «вытащить все ID». Для общих запросов это почти все 5k — терпимо, но это лишний шаг и данные гоняются через PHP.
- Набор ID нужно материализовать для каждого запроса, иначе `WHERE id IN (...)` может разрастись и тормозить план запроса.
- Два источника правды (поиск — TNTSearch, агрегации — MySQL); возможна рассинхронизация, если индекс не успевает обновляться.

Лучше всего подходит:
- Если хотите повысить качество поиска без развёртывания отдельного сервиса и согласны с материализацией ID в MySQL. На 5k — рабочий вариант.

3) Manticore Search (лёгкий внешний сервис) — «унифицированный» поиск + фасеты
Суть:
- Поиск и фасеты целиком в Manticore: русская морфология, BM25, `FACET`-агрегации, поддержка MVA (мультизначные атрибуты).

Инструменты:
- Docker `manticoresearch/manticore`.
- `manticoresearch-php`.
- В RT‑индексе хранить:
  - поля текста (`name`, `description`),
  - фильтруемые атрибуты/опции как MVA (`option_color_ids`, `attr_power_values`, и т.п.),
  - `category_id`, `price`, `active`.

Как считать counts:
- Один запрос в Manticore с фильтрами + `FACET` по нужным полям. Для self-exclusion — делаете отдельные `FACET` по каждому измерению на общих фильтрах, исключая текущий.
- Возвращаете counts прямо из Manticore.
- Для списка товаров берёте `ids` в нужном порядке и подтягиваете сущности из MySQL.

Плюсы:
- Идеальная совместимость поискового набора и агрегаций — один движок, одна консистентность.
- Морфология «из коробки», быстрая релевантность, простой `FACET`.

Минусы:
- Отдельный сервис (пусть и лёгкий).
- Нужно синхронизировать индекс (RT‑индекс + апдейты по событиям).

Лучше всего подходит:
- «План Б» с внешним движком, когда хотите высокое качество поиска и максимально удобные фасеты без «перекладывания ID» в MySQL.

4) Elasticsearch / OpenSearch — «максимум удобства», избыточно для 5k
Суть:
- Поиск и агрегации (`terms`, `range`, `histogram`, `filters`) в одном запросе, `russian` analyzer.

Инструменты:
- Docker ES/OS, клиент `elasticsearch/elasticsearch` или `ruflin/elastica`.

Как считать counts:
- Один `search` с `query` + набором `aggregations` по нужным полям. Self-exclusion — через отдельные агрегации per dimension (фильтрованные).
- Товары — по `ids` из `hits`, сущности — из MySQL.

Плюсы:
- Лучшая гибкость агрегаций, подсветка, синонимы, опечатки.

Минусы:
- Относительно тяжёлая инфраструктура для 5k.

Лучше всего подходит:
- Если кроме поиска нужны сложные аналитические агрегации/отчёты, и инфраструктура не проблема.

Нужно ли делать «отдельный фильтр по агрегациям» для поисковых запросов?
- Нет. Достаточно одного эндпоинта `/api/catalog/facets` с параметрами `category`, `q`, выбранные фильтры и пагинация. Реализация внутри:
  - Подход 1 (MySQL+леммы): всё в одном запросном плане MySQL (CTE base + GROUP BY).
  - Подход 2 (TNTSearch): шаг 1 — материализовать `product_id` в `TEMP TABLE`; шаг 2 — те же GROUP BY в MySQL.
  - Подход 3/4 (Manticore/ES): поиск и агрегации в самом движке; контракт API тот же.

Практические заметки по реализации единого эндпоинта фасетов
- Принцип self-exclusion: для каждой группы фасета считайте counts на «базовом наборе», где применены все текущие фильтры, кроме самой этой группы. Делать это отдельными SQL на каждую группу проще и на 5k SKU очень быстро.
- Материализация базового набора:
  - MySQL‑only: используйте CTE `base` с полным WHERE (включая `MATCH()`).
  - TNTSearch: `CREATE TEMPORARY TABLE tmp_search_ids` + JOIN внутри CTE.
- Производительность:
  - Индексы из вашего плана + `EXPLAIN` + `STRAIGHT_JOIN` при необходимости.
  - Если `IN (...)` всё же используется — не больше 1000–2000 элементов; лучше `TEMP TABLE`.
- Консистентность:
  - Нормализатор запроса (`LemmaNormalizer`) должен быть общим для списка и фасетов, чтобы базовый набор всегда совпадал с выдачей.
  - Для внешних движков используйте одну и ту же «проекцию фильтров» (категория/опции/атрибуты) в обоих запросах.

Рекомендация под ваш ТЗ
- На текущем дизайне «живых» агрегаций и малом каталоге оптимален «MySQL FULLTEXT + лемматизация в приложении». Это самый бесшовный вариант: один источник, один план запросов, никаких «переносов ID».
- Если захочется лучшей релевантности/опечаток без обслуживания тяжёлого кластера — Manticore как План Б: и поиск, и агрегации делайте в нём. `facet_dictionary` и `FacetConfig` остаются в MySQL (для админки), это не конфликтует.
- TNTSearch годится, но потребует материализации ID в MySQL для корректных counts — дополнительная связка, которую логично избегать, раз MySQL и так справляется.

Если нужно, могу наметить:
- `SearchScope` DTO (category, q, filters) + единый сервис построения «базового набора».
- SQL-шаблоны `base + GROUP BY` для дискретных/числовых атрибутов.
- Реализацию «материализации ID» через `TEMP TABLE` и безопасные батчевые вставки.