Коротко: не выбрасывай текущую систему тем. Переведи её в переиспользуемый пакет/бандл и переходи на архитектуру отдельных приложений (Простые шаблоны) для каждого магазина. Таким образом ты сохранишь наработки по `ThemeLoader/ThemeManager`, но уйдёшь от рисков мульти‑БД и разных хостингов в одном инстансе.

Практический план

Вариант A (рекомендуемый): гибрид — отдельные приложения + переиспользуемая тема как бандл
1) Выдели бизнес‑ядро и тему в пакеты:
   - `ecommerce-core` — сервисы, контракты репозиториев, DTO, базовые контроллеры (без жёсткой ORM‑схемы).
   - `app-theme-bundle` — твоя текущая `src/Theme/**` как отдельный Symfony‑бандл.
     - Перенеси `ThemeManager`, `ThemeListener`, `ThemeLoader`, `ThemeExtension`, `ThemeAssetPackage` в пакет с неймспейсом, например, `YourVendor\AppThemeBundle`.
     - Оформи `composer.json` (`type: symfony-bundle`), добавь `Bundle` класс, DI‑`Extension`.
     - Вынеси конфиги из `config/packages/app_theme.yaml` в `app-theme-bundle` (с поддержкой параметров).

2) В каждом магазине — отдельный Symfony‑app:
   - Подключи `ecommerce-core` и `app-theme-bundle` через Composer.
   - В `config/bundles.php` включи `AppThemeBundle`.
   - Используй обычные `templates/` и `assets/` магазина. Если нужен подбор нескольких дизайнов внутри одного магазина — включай темы (ты уже умеешь это делать).
   - Своя БД, свои миграции, свои ORM‑entities/репозитории, маппинг контракта `ProductRepositoryInterface` из `core` на свою реализацию.

3) Мигрируй существующие темы в магазины:
   - Для темы `themes/default` создай магазин `shop-default`.
   - Скопируй `themes/default/templates/**` → `shop-default/templates/**`.
   - Скопируй `themes/default/assets/**` → `shop-default/assets/**`. В `entry.ts` импортируй общий bootstrap из `core` (или оставь локально).
   - Настрой `twig.paths` на `vendor/yourvendor/ecommerce-core/templates` как fallback (`@CoreTemplates`), чтобы переиспользовать общие partial’ы.
   - Убери рантайм‑переключение по сессии/параметру — теме больше не нужно «переключаться между магазинами», у магазина один дизайн по умолчанию.

4) Поддержи отличия в схемах БД:
   - В `core` оставь только контракты (`ProductRepositoryInterface`, `CategoryRepositoryInterface`) и DTO (`ProductView`, `CategoryView`).
   - Реализации репозиториев и entities — в каждом магазине свои (под свою БД).
   - Если отличия минимальные — можно использовать `MappedSuperclass` в `core` + конкретные `@ORM\Entity` в магазине. Если отличий больше — лучше чистые интерфейсы + адаптеры.

5) CI/CD:
   - Монорепо или несколько репо: матрица обновлений `core` по магазинам.
   - На деплой каждого магазина — свой пайплайн, своя БД/секреты.
   - Сборка ассетов — локально в магазине (тебе уже не нужен общий сканер `themes/*` в одном проекте).

6) Что сделать с текущим рантайм‑ThemeListener:
   - В бандле оставь, но ограничь сценарии использования: предпросмотр (`?_theme`) или несколько дизайнов в рамках одного магазина.
   - Убери выбор темы из сессии в проде, и не используй его для кросс‑магазинного переключения (разные БД и хостинги этому противоречат).

Быстрый «экспорт» темы в отдельный магазин
- Напиши простую CLI‑команду `bin/console app:theme:export <code> --dest=../shop-<code>`:
  - Копирует `themes/<code>/templates/**` → `<dest>/templates/**`.
  - Копирует `themes/<code>/assets/**` → `<dest>/assets/**`.
  - Создаёт `<dest>/config/packages/twig.yaml` с `paths` на `core`.
  - Генерит минимальный `webpack.config.js` и `composer.json` магазина.
- Это даст тебе 1‑клик миграцию существующих тем в отдельные проекты.

Вариант B: оставить один инстанс и поддержать многобазность (не рекомендую под разные хостинги)
Если нужно временно не дробить приложение, то:
- Добавь `TenantResolver` (по хосту/субдомену) и храни `tenant` в `Request` (рядом с `_theme`).
- Сделай мульти‑EM: `doctrine.orm.entity_managers.shop_a`, `shop_b`, разные `dbal.connections.*`. На рантайме выбирай нужный `EntityManager` по `tenant`.
- Разведи миграции per‑tenant (`migrations.{tenant}.yaml` + отдельные пути).
- Добавь строгий `Vary: Host` и раздельные кэш‑ключи.
- Минусы: сложность растёт сильно, а у тебя «разные хостинги» — это ещё и сетевые риски (latency, секреты), так что лучше уйти на отдельные приложения.

Что точно стоит сделать прямо сейчас
- Зафиксировать существующую систему тем как переиспользуемый бандл (`app-theme-bundle`). Ты уже вложился — это окупится и в отдельных магазинах.
- Ограничить механику выбора темы (убрать зависимость от сессии в проде).
- Добавить автотест на резолюцию шаблонов и анти‑рекурсивный линт (`twigcs`).
- Подготовить «скелет магазина» (шаблон проекта), который за 10 минут разворачивается и использует `core` + `app-theme-bundle`.

Итого
- Система тем — твой актив: превращай в бандл и используй в каждом отдельном магазине локально.
- Артефакты из `themes/<code>` переносишь в `templates/`/`assets/` конкретного магазина, сводя рантайм‑переключение к минимуму.
- Для разных БД и хостингов — отдельные приложения: проще, безопаснее и масштабируемее.
- При необходимости несколько дизайнов внутри одного магазина — у тебя уже есть готовый `ThemeLoader`, просто используй его там, где это действительно нужно.