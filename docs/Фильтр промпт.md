Ниже — готовый промпт для ИИ-агента под ваш репозиторий. Его можно целиком вставить в Cursor.

```text
Роль: Ты — senior Symfony/API Platform + Doctrine + Vue 3/TS разработчик. Работаешь в существующем проекте (Symfony, API Platform, Vue Admin SPA, Catalog FSD).

Цель: Реализовать фасетный фильтр по документу `docs/Фильтр.md`: админ-конфиг фасетов, кэш справочников (dictionary) с переиндексацией, витринный эндпоинт «живых» counts, страница настроек в Admin SPA.

Ограничения и правила (важно):
- Scope поиска/работы: 
  - Backend: `src/**`, `config/**`, `migrations/**`, `templates/**`, `docs/**`
  - Admin SPA: `assets/admin/**`
  - Catalog: `assets/catalog/**`
  - Исключить: `vendor/**`, `node_modules/**`, `public/**`, `var/**`
- Используй маяки (якоря) и узкий поиск:
  - Admin SPA: вход/роутер/HTTP/store — ищи по `// ai:` и по ключам `createApp(App)`, `createRouter`, `interceptors`
  - Catalog: `assets/catalog/src/app/registry.ts` (реестр), `assets/catalog/catalog.ts` (вход), `@shared/api/http`
- Архитектура фронта:
  - Admin SPA: следуй локальной архитектуре `admin_js_architecture`
  - Catalog: FSD (`assets/catalog/src/**`) и правила из `repo_specific_rule` (TypeScript, shared/ui Component, разделение API/UI)
- Конфигурация: никаких хардкодов. Значения TTL, лимитов и пр. — через `config/services.yaml` и `.env` (см. «Configuration Management Rules»).
- Segurança: админские эндпоинты — только для ролей админки (см. `admin_auth_policy`).

Что нужно сделать (бэкенд):

1) Миграции БД и индексы
- Создай таблицу `facet_dictionary`:
  - Поля: `id` PK, `category_id` (nullable, FK на `Category`), `attributes_json` JSON, `options_json` JSON, `price_min` INT nullable, `price_max` INT nullable, `updated_at` DATETIME NOT NULL.
  - Индексы: `UNIQUE(category_id)` (допускается ровно одна запись на категорию; для GLOBAL — `category_id IS NULL`, должна быть максимум одна запись).
- Добавь индексы для стабильности:
  - `product_option_value_assignment`: `idx_pova_product (product_id)`, `idx_pova_product_option (product_id, option_id)` — проверь существующие индексы и добавь недостающие.
  - `product_to_category`: `idx_ptc_category_product (category_id, product_id)` (сейчас есть по отдельности; нужен составной для выборок «по категории»).
  - `product_attribute_assignment`: `idx_paa_string (string_value)` — для админских подсказок/поиска.

2) Сущность `FacetConfig` (ApiResource)
- Файл: `src/Entity/FacetConfig.php`
- Поля:
  - `id`, `scope` enum `'GLOBAL'|'CATEGORY'`, `category` (ManyToOne `Category`, nullable)
  - `attributes` JSON: массив `{ code, enabled, widget: 'checkbox'|'range', operator?: 'OR'|'AND', order?: number, bins?: number|Array<[min,max]> }`
  - `options` JSON: массив `{ code, enabled, widget: 'checkbox'|'range', order?: number, bins?: ... }`
  - Флаги/параметры: `showZeros` (bool), `collapsedByDefault` (bool), `valuesLimit` (int, по умолчанию из параметров), `valuesSort` (`'popularity'|'alpha'|'manual'`)
- Инварианты:
  - Уникальность: ровно один `GLOBAL` (category=NULL), не более одного на категорию. Добавь `UniqueEntity` и БД-ограничения.
  - В репозитории сделай метод `findEffectiveConfigForCategory(int $categoryId): FacetConfig` (CATEGORY override → иначе GLOBAL).

3) Сервис индексации `FacetIndexer`
- Файл: `src/Service/FacetIndexer.php`
- Методы:
  - `reindexCategory(int $categoryId)`: собрать набор активных товаров категории; вычислить:
    - Атрибуты: DISTINCT по `ProductAttributeAssignment` (код, имя, тип, min/max для числовых)
    - Опции: DISTINCT по `ProductOptionValueAssignment` (код/значения; для числовых — min/max по `height|bulbsCount|lightingArea`)
    - Диапазоны цены: `price_min/price_max` по `Product.effective_price` (при необходимости учитывай вариации)
  - `reindexAll()`: батчево по всем категориям
- Сохранение: UPSERT в `facet_dictionary` (одна запись на категорию/глобал).
- Производительность: используем индексы, минимизируем JOIN’ы.

4) Триггеры/деферы пересчёта
- События Doctrine: `Product`, `ProductToCategory`, `ProductAttributeAssignment`, `ProductOptionValueAssignment`, а также `Attribute/AttributeGroup/Option/OptionValue`.
- Реализация: `src/EventSubscriber/FacetReindexSubscriber.php`
  - Кладём изменённые `category_id` в in-memory очередь (debounce)
  - В `kernel.terminate` (или лёгкий отложенный механизм) — запускаем пересчёт уникальных категорий
  - Если Messenger не используется — делаем короткий синхронный пересчёт, но с агрегацией повторов

5) Эндпоинты (админ)
- Контроллер: `src/Controller/Admin/FacetController.php` (или кастомные операции API Platform)
  - `GET /api/admin/facets/available?category=<id|null>` — из `facet_dictionary` (с ETag/Cache-Control)
  - `GET /api/admin/facets/config?category=<id|global>` — отдаёт эффективную конфигурацию
  - `PUT /api/admin/facets/config` — сохраняет конфиг (валидируй схему)
  - `POST /api/admin/facets/reindex?category=<id|all>` — ручной пересчёт; возвращай 202 Accepted
- Доступ: только роли админки (см. `admin_auth_policy`)

6) Эндпоинт (витрина)
- Контроллер: `src/Controller/Catalog/FacetsController.php`
  - `GET /api/catalog/facets?...` — живые counts по текущему набору (учитывает все фильтры как `/api/products`)
  - Ограничивает перечень фасетов `FacetConfig` (CATEGORY → GLOBAL)
  - Реализация: `QueryBuilder` + `GROUP BY` по каждому фасету; короткий кэш (30–120 сек). Разрешено использовать `facet_dictionary` для ранней фильтрации пустых групп, но counts всегда живые.
- Цена: Определи семантику. Вариант по умолчанию — фильтр по `Product.effective_price` (добавить `RangeFilter` если нужно) или по `optionAssignments.price`. Зафиксируй явно и покрый тестами.

7) Конфигурация и кэш
- `config/services.yaml`: параметры
  - `app.facets.cache_ttl`: `%env(int:FACETS_CACHE_TTL)%` (например 60–120)
  - `app.facets.values_limit_default`: `%env(int:FACET_VALUES_LIMIT)%` (например 20)
- В контроллерах: отвечать с ETag/Last-Modified и `Cache-Control: public, max-age=...` там, где безопасно.

8) Тесты
- Unit: `FacetIndexer` (категория → словарь; min/max и списки уникальных значений)
- Functional:
  - `GET /api/admin/facets/available` (роль, ETag)
  - `PUT /api/admin/facets/config` (валидация, uniqueness, upsert)
  - `POST /api/admin/facets/reindex` (202 + побочный эффект)
  - `GET /api/catalog/facets` (фильтры применяются, фасеты ограничены конфигом, counts корректны)
- Производительность: на фикстурах <5000 SKU ответ `/api/catalog/facets` ≤ 100–150 мс

Что нужно сделать (Admin SPA, `assets/admin/**`):
- Новая страница «Каталог → Фасетный фильтр»:
  - Роут в админ-роутере, меню
  - Слева выбор категории (или «Глобально»), справа билдер фасетов
  - Автоподстановка доступных атрибутов/опций из `GET /api/admin/facets/available`
  - Поля для `widget`, `operator` (только для атрибутов), `order`, `bins`, флаги `showZeros`, `collapsedByDefault`, `valuesLimit`, `valuesSort`
  - Кнопки: «Сохранить» (PUT config), «Перестроить справочники» (POST reindex), «Сбросить»
- HTTP-клиент: используй уже существующий клиент и interceptors (см. маяк `// ai:http-client area=admin exports=HttpClient,httpClient`)
- TypeScript типы для FacetConfig/Dictionary, обработка ошибок, тосты
- Без хардкодов, локализация подписей

Что нужно сделать (Catalog, `assets/catalog/**`) — минимально:
- Подготовить модуль API для `GET /api/catalog/facets` и добавить использование на странице категории для перечня фасетов (counts живые). Визуальный вид можно оставить базовым, главное — чтение конфига и перечисление фасетов.

Контракты ответов (ориентиры):
- `GET /api/admin/facets/available`
  {
    "categoryId": 123|null,
    "attributes": [
      { "code": "material", "name": "Материал", "type": "string", "min": null, "max": null }
    ],
    "options": [
      { "code": "color", "name": "Цвет", "values": [ { "code": "red", "label": "Красный" } ] }
    ],
    "price": { "min": 1200, "max": 25990 },
    "updatedAt": "2025-09-29T10:15:00+03:00"
  }
- `GET /api/admin/facets/config?category=<id|global>`
  {
    "scope": "CATEGORY"|"GLOBAL",
    "categoryId": 123|null,
    "attributes": [ { "code": "material", "enabled": true, "widget": "checkbox", "operator": "OR", "order": 10 } ],
    "options":    [ { "code": "color", "enabled": true, "widget": "checkbox", "order": 20 } ],
    "showZeros": false,
    "collapsedByDefault": true,
    "valuesLimit": 20,
    "valuesSort": "popularity"
  }
- `GET /api/catalog/facets?...`
  {
    "facets": {
      "color": { "type": "option", "values": [ { "code": "red", "label": "Красный", "count": 12 }, ... ] },
      "material": { "type": "attribute", "values": [ { "code": "wood", "label": "Дерево", "count": 5 }, ... ] },
      "price": { "type": "range", "min": 1200, "max": 25990 }
    }
  }

Acceptance-критерии:
- Миграции применяются, индексы созданы, одна запись `facet_dictionary` на категорию и максимум одна глобальная
- `FacetConfig` CRUD работает, уникальность соблюдается, `findEffectiveConfigForCategory` корректен
- `POST /api/admin/facets/reindex` даёт 202 и реально перестраивает запись
- `GET /api/admin/facets/available` → ETag/Cache-Control, данные соответствуют факту
- `GET /api/catalog/facets` ограничивает перечень фасетов по конфигу и возвращает живые counts
- Admin SPA: страница доступна из меню, сохраняет конфиг, умеет запускать reindex, UX без ошибок
- Нет хардкодов; конфиги/TTL через `config/services.yaml` + `.env`
- Линтер/типы/тесты проходят

Важно:
- Оператор AND для дискретных опций по умолчанию не включать (дороже запросы); включать опционально для атрибутов
- Определи и зафиксируй семантику ценового фильтра (по `Product.effective_price` или по вариациям)
- Соблюдай политику производительности агента: не сканируй весь репозиторий без необходимости, используй маяки и точечные файлы
- Любые новые `.mdc`-правила — в `.cursor/rules/` по шаблону (front‑matter и ссылки), если добавляешь

Сразу приступай к реализации по шагам в порядке выше. По завершении — кратко опиши внесённые файлы/правки и приложи пример ответов эндпоинтов.
```

- Если нужен, подготовлю отдельный короткий промпт только для бэкенда или только для Admin SPA.