Вот итоговый аудит внедрения промпта (по пунктам ТЗ).

- Модель/миграции — сделано
  - `User`: `email` (lower/unique), `isVerified`, `lastLoginAt`, `failedLoginAttempts`, `lockedUntil`, `tokenVersion`.
  - Таблицы: `user_refresh_token`, `user_one_time_token` (opaque‑токены, HMAC+salt+pepper).
  - Миграция добавлена; требуется выполнить doctrine:migrations:migrate.

- Эндпойнты — сделано
  - Публичные: POST `/api/customer/auth/{register,login,refresh,logout,password/request,password/confirm,email/verify,revoke-all}`.
  - Защищённый профиль: GET `/api/customer/me`.

- Security/firewalls — сделано
  - Отдельные firewalls: `^/api/customer/auth` (public), `^/api/customer` (JWT), `^/account` (JWT).
  - Доступ: `IS_AUTHENTICATED_FULLY` для `^/api/customer` и `^/account`.
  - Lexik extractor: cookie `__Host-acc` приоритетнее Authorization (декоратор chain extractor).

- JWT/cookies — сделано частично
  - Access: `__Host-acc` (httpOnly, Secure, SameSite=Lax), TTL из ENV.
  - Refresh: кастомная реализация (БД), ручная кука (httpOnly, Secure, SameSite=Strict), ротация при `/refresh`, отзыв `/revoke-all`.
  - remove_token_from_body_when_cookies_used=true — выставлено.
  - Замечание: обязательной проверки `isVerified` перед выдачей refresh нет (сейчас refresh выдаётся сразу после логина) — это расходится с ТЗ.

- RateLimiter — сделано
  - Конфиги `auth_register`, `auth_login`, `auth_refresh`, `auth_pwd_request`.

- Anti‑timing/anti‑enumeration — сделано
  - Случайная задержка для неуспехов; унифицированные ответы.

- Пароли/хеш — частично
  - Хеш — Symfony auto (argon2id приоритетен в auto‑профиле).
  - Усиленная политика паролей (длина/сложность) — не внедрена (нет серверной валидации).

- Lockout per‑account — не сделано
  - Поля есть, но логика инкремента `failedLoginAttempts` и блокировки `lockedUntil` не реализована.

- Email verify/reset — сделано частично
  - Opaque‑токены (HMAC+salt+TTL), `/email/verify`, `/password/request`, `/password/confirm` — есть.
  - Ссылки в письмах ведут на фронт: verify → `/auth/login?verify_token=...` (верификация триггерится после логина). ТЗ просило POST‑верификацию без логина; это работает, но UX лучше вынести в отдельную verify‑страницу с автопостом токена.

- CORS — сделано
  - Отдельный профиль для `/api/customer/auth/*` с `allow_credentials: true`, origin из `APP_FRONTEND_BASE_URL`.

- Логи/аудит — частично
  - Логирование попыток логина/lockout/reset/revocation отдельно не добавлено (кроме стандартных событий Lexik); отдельный security‑канал не настраивался под это.

- Немедленная инвалидция access (tokenVersion/Redis) — частично
  - В JWT добавлен claim `tv`, проверка через CacheInterface + fallback на БД — есть.
  - ТТL кэша/явный Redis и «+60s» из ТЗ — не настроены (сейчас кэш без явного TTL и без гарантированного Redis).

- Конфигурация через ENV/parameters — сделано
  - `JWT_ACCESS_TTL`, `JWT_REFRESH_TTL`, `AUTH_*`, `APP_PEPPER`, `APP_FRONTEND_BASE_URL` и пр.; Mailer `MAILER_DSN` документирован; `From` внедрён через `ADMIN_FROM_EMAIL`.

- Frontend (Catalog/Twig/FSD) — сделано
  - Страницы: `/auth/login`, `/auth/register`, `/auth/password/request`, `/auth/password/reset`, `/account` (JWT‑защита).
  - Модули: `auth-login`, `auth-register`, `auth-password`; регистрация в реестре.
  - Редирект после логина → `/account`; verify‑токен обрабатывается на логине.
  - Ссылки «Войти/Регистрация» в хедере — подключены.

- Тесты — сделано (базово)
  - Функциональный тест общего флоу (register → login → me → refresh → revoke).

Итог
- Покрыто: архитектура security, JWT/cookies, refresh‑ротация, email/reset‑токены, RateLimiter, CORS, anti‑timing, frontend формы/модули, учет конфигов.
- Остались 4 ключевые доработки для 100% соответствия ТЗ:
  - Проверка `isVerified` перед выдачей refresh (либо режим «без refresh до верификации»).
  - Реальная политика паролей (длина/сложность) с серверной валидацией.
  - Lockout per‑account: инкремент/сброс попыток + окно блокировки.
  - JWT tokenVersion cache в Redis с TTL = access_ttl+60s (и явный fallback, запись в кэш после БД).

Рекомендованные next steps (коротко)
- В `login`: если `!user.isVerified` — либо не выдавать refresh (только access), либо возвращать 403/409 с подсказкой «подтвердите email».
- Добавить валидаторы пароля (Constraint) и сообщения (422).
- Реализовать инкремент `failedLoginAttempts` и `lockedUntil` (сброс на успешный вход).
- Настроить Redis pool для `cache.app` и TTL в подписчике `JwtTokenVersionSubscriber`.
- (Опционально) Отдельная `/auth/email/verify` страница (FSD) с автопостом токена, чтобы не требовать входа для подтверждения.