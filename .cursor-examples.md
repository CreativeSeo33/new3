# –ü—Ä–∏–º–µ—Ä—ã –∫–æ–¥–∞ –¥–ª—è Cursor AI

## üìã Feature Module Examples

### Product Review Feature

**–°—Ç—Ä—É–∫—Ç—É—Ä–∞:**
```
features/product-review/
‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îî‚îÄ‚îÄ index.ts
‚îú‚îÄ‚îÄ ui/
‚îÇ   ‚îî‚îÄ‚îÄ component.ts
‚îî‚îÄ‚îÄ index.ts
```

**API (api/index.ts):**
```typescript
import { get, post } from '@shared/api/http';
import type { ReviewRequest, ReviewResponse } from '@shared/types/api';

export async function getProductReviews(productId: number): Promise<ReviewResponse[]> {
  return get<ReviewResponse[]>(`/api/products/${productId}/reviews`);
}

export async function createReview(productId: number, data: ReviewRequest): Promise<ReviewResponse> {
  return post<ReviewResponse>(`/api/products/${productId}/reviews`, data);
}

export async function updateReview(reviewId: number, data: Partial<ReviewRequest>): Promise<ReviewResponse> {
  return post<ReviewResponse>(`/api/reviews/${reviewId}`, data, { method: 'PATCH' });
}
```

**UI (ui/component.ts):**
```typescript
import { Component } from '@shared/ui/Component';
import { getProductReviews, createReview } from '../api';
import type { ReviewResponse, ReviewRequest } from '@shared/types/api';

interface ReviewOptions {
  productId?: number;
  showForm?: boolean;
  maxReviews?: number;
}

export class ProductReviewComponent extends Component {
  private reviews: ReviewResponse[] = [];
  private options: ReviewOptions;
  private loading = false;

  constructor(el: HTMLElement, opts: ReviewOptions = {}) {
    super(el, opts);

    this.options = {
      showForm: true,
      maxReviews: 10,
      ...opts
    };

    this.init();
  }

  init(): void {
    this.loadReviews();

    if (this.options.showForm) {
      this.renderReviewForm();
    }

    this.on('submit', this.handleReviewSubmit.bind(this), { passive: false });
  }

  private async loadReviews(): Promise<void> {
    if (!this.options.productId) return;

    this.loading = true;
    this.showLoading();

    try {
      this.reviews = await getProductReviews(this.options.productId);
      this.renderReviews();
    } catch (error) {
      console.error('Error loading reviews:', error);
      this.showError('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –æ—Ç–∑—ã–≤—ã');
    } finally {
      this.loading = false;
      this.hideLoading();
    }
  }

  private renderReviews(): void {
    const reviewsEl = this.$('[data-reviews]');
    if (!reviewsEl) return;

    const reviewsHtml = this.reviews
      .slice(0, this.options.maxReviews)
      .map(review => `
        <div class="review-item" data-review-id="${review.id}">
          <div class="review-header">
            <strong>${review.authorName}</strong>
            <div class="rating">${'‚òÖ'.repeat(review.rating)}${'‚òÜ'.repeat(5 - review.rating)}</div>
          </div>
          <p class="review-text">${review.comment}</p>
          <small class="review-date">${new Date(review.createdAt).toLocaleDateString()}</small>
        </div>
      `)
      .join('');

    reviewsEl.innerHTML = reviewsHtml;
  }

  private renderReviewForm(): void {
    const formEl = this.$('[data-review-form]');
    if (!formEl) return;

    formEl.innerHTML = `
      <form data-review-form>
        <div class="form-group">
          <label for="rating">–†–µ–π—Ç–∏–Ω–≥:</label>
          <select id="rating" name="rating" required>
            <option value="5">‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ</option>
            <option value="4">‚òÖ‚òÖ‚òÖ‚òÖ‚òÜ</option>
            <option value="3">‚òÖ‚òÖ‚òÖ‚òÜ‚òÜ</option>
            <option value="2">‚òÖ‚òÖ‚òÜ‚òÜ‚òÜ</option>
            <option value="1">‚òÖ‚òÜ‚òÜ‚òÜ‚òÜ</option>
          </select>
        </div>
        <div class="form-group">
          <label for="comment">–û—Ç–∑—ã–≤:</label>
          <textarea id="comment" name="comment" required></textarea>
        </div>
        <button type="submit" class="btn-submit">–û—Ç–ø—Ä–∞–≤–∏—Ç—å –æ—Ç–∑—ã–≤</button>
      </form>
    `;
  }

  private async handleReviewSubmit(e: Event): Promise<void> {
    e.preventDefault();

    const form = e.target as HTMLFormElement;
    const formData = new FormData(form);

    const reviewData: ReviewRequest = {
      rating: parseInt(formData.get('rating') as string, 10),
      comment: formData.get('comment') as string,
      authorName: 'Anonymous' // –í —Ä–µ–∞–ª—å–Ω–æ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏ –±—Ä–∞—Ç—å –∏–∑ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏
    };

    if (!this.options.productId) {
      this.showError('ID —Ç–æ–≤–∞—Ä–∞ –Ω–µ —É–∫–∞–∑–∞–Ω');
      return;
    }

    this.loading = true;
    const submitBtn = form.querySelector('.btn-submit') as HTMLButtonElement;
    if (submitBtn) {
      submitBtn.disabled = true;
      submitBtn.textContent = '–û—Ç–ø—Ä–∞–≤–∫–∞...';
    }

    try {
      const newReview = await createReview(this.options.productId, reviewData);
      this.reviews.unshift(newReview);
      this.renderReviews();

      // –û—á–∏—Å—Ç–∫–∞ —Ñ–æ—Ä–º—ã
      form.reset();

      // –ü–æ–∫–∞–∑–∞—Ç—å —É—Å–ø–µ—Ö
      this.showSuccess('–û—Ç–∑—ã–≤ —É—Å–ø–µ—à–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω');

      // –û—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–±—ã—Ç–∏–µ
      window.dispatchEvent(new CustomEvent('review:created', {
        detail: { review: newReview }
      }));

    } catch (error) {
      console.error('Error creating review:', error);
      this.showError('–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –æ—Ç–∑—ã–≤');
    } finally {
      this.loading = false;
      if (submitBtn) {
        submitBtn.disabled = false;
        submitBtn.textContent = '–û—Ç–ø—Ä–∞–≤–∏—Ç—å –æ—Ç–∑—ã–≤';
      }
    }
  }

  private showLoading(): void {
    const loader = this.$('[data-loading]');
    if (loader) {
      loader.classList.remove('hidden');
    }
  }

  private hideLoading(): void {
    const loader = this.$('[data-loading]');
    if (loader) {
      loader.classList.add('hidden');
    }
  }

  private showSuccess(message: string): void {
    // –ü–æ–∫–∞–∑–∞—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± —É—Å–ø–µ—Ö–µ
    console.log('Success:', message);
  }

  private showError(message: string): void {
    // –ü–æ–∫–∞–∑–∞—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ
    console.error('Error:', message);
  }

  // –ü—É–±–ª–∏—á–Ω—ã–µ –º–µ—Ç–æ–¥—ã
  public refresh(): void {
    this.loadReviews();
  }

  public setProductId(productId: number): void {
    this.options.productId = productId;
    this.loadReviews();
  }

  destroy(): void {
    // –û—á–∏—Å—Ç–∫–∞ —Ä–µ—Å—É—Ä—Å–æ–≤
    this.reviews = [];
    super.destroy();
  }
}
```

**Index (index.ts):**
```typescript
import { ProductReviewComponent } from './ui/component';

export interface ProductReviewOptions {
  productId?: number;
  showForm?: boolean;
  maxReviews?: number;
}

export function init(
  root: HTMLElement,
  opts: ProductReviewOptions = {}
): () => void {
  const component = new ProductReviewComponent(root, opts);
  return () => component.destroy();
}

export {
  getProductReviews,
  createReview,
  updateReview
} from './api';

export { ProductReviewComponent };
export type { ProductReviewOptions };
```

**–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –≤ HTML:**
```html
<div data-module="product-review"
     data-product-id="123"
     data-max-reviews="5">
  <div data-loading class="loading-spinner hidden">–ó–∞–≥—Ä—É–∑–∫–∞...</div>
  <div data-reviews></div>
  <div data-review-form></div>
</div>
```

## üõí Widget Module Examples

### Shopping Cart Widget

**widgets/shopping-cart/index.ts:**
```typescript
import { Component } from '@shared/ui/Component';
import { get } from '@shared/api/http';
import { formatPrice } from '@shared/lib/formatPrice';
import type { CartResponse, CartItem } from '@shared/types/api';

interface CartOptions {
  showTotal?: boolean;
  showItems?: boolean;
  maxItems?: number;
}

export class ShoppingCartWidget extends Component {
  private cart: CartResponse | null = null;
  private options: CartOptions;

  constructor(el: HTMLElement, opts: CartOptions = {}) {
    super(el, opts);

    this.options = {
      showTotal: true,
      showItems: true,
      maxItems: 3,
      ...opts
    };

    this.init();
  }

  init(): void {
    this.loadCart();

    // –°–ª—É—à–∞–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∫–æ—Ä–∑–∏–Ω—ã
    window.addEventListener('cart:updated' as any, this.handleCartUpdate.bind(this));

    // –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∫–ª–∏–∫–æ–≤
    this.on('click', this.handleClick.bind(this));
  }

  private async loadCart(): Promise<void> {
    try {
      this.cart = await get<CartResponse>('/api/cart');
      this.render();
    } catch (error) {
      console.error('Error loading cart:', error);
    }
  }

  private handleCartUpdate(e: CustomEvent<CartResponse>): void {
    this.cart = e.detail;
    this.render();
  }

  private handleClick(e: Event): void {
    const target = e.target as HTMLElement;

    if (target.matches('[data-remove-item]')) {
      const itemId = target.dataset.itemId;
      if (itemId) {
        this.removeItem(parseInt(itemId, 10));
      }
    }

    if (target.matches('[data-view-cart]')) {
      // –ü–µ—Ä–µ—Ö–æ–¥ –≤ –∫–æ—Ä–∑–∏–Ω—É
      window.location.href = '/cart';
    }
  }

  private async removeItem(itemId: number): Promise<void> {
    try {
      // API call to remove item
      await get(`/api/cart/items/${itemId}/remove`);
      // Cart will be updated via event
    } catch (error) {
      console.error('Error removing item:', error);
    }
  }

  private render(): void {
    if (!this.cart) return;

    const { items, total } = this.cart;

    // –†–µ–Ω–¥–µ—Ä–∏–º —Å—á–µ—Ç—á–∏–∫ —Ç–æ–≤–∞—Ä–æ–≤
    const counterEl = this.$('[data-cart-count]');
    if (counterEl) {
      counterEl.textContent = items.length.toString();
    }

    // –†–µ–Ω–¥–µ—Ä–∏–º –æ–±—â—É—é —Å—É–º–º—É
    if (this.options.showTotal) {
      const totalEl = this.$('[data-cart-total]');
      if (totalEl) {
        totalEl.textContent = formatPrice(total);
      }
    }

    // –†–µ–Ω–¥–µ—Ä–∏–º —Å–ø–∏—Å–æ–∫ —Ç–æ–≤–∞—Ä–æ–≤
    if (this.options.showItems) {
      const itemsEl = this.$('[data-cart-items]');
      if (itemsEl) {
        const itemsHtml = items
          .slice(0, this.options.maxItems)
          .map(item => `
            <div class="cart-item" data-item-id="${item.id}">
              <img src="${item.image}" alt="${item.name}" class="cart-item-image">
              <div class="cart-item-info">
                <h4>${item.name}</h4>
                <p>${formatPrice(item.effectiveUnitPrice)} √ó ${item.qty}</p>
              </div>
              <button data-remove-item data-item-id="${item.id}">√ó</button>
            </div>
          `)
          .join('');

        itemsEl.innerHTML = itemsHtml;
      }
    }
  }

  // –ü—É–±–ª–∏—á–Ω—ã–µ –º–µ—Ç–æ–¥—ã
  public refresh(): void {
    this.loadCart();
  }

  public getItemCount(): number {
    return this.cart?.items.length || 0;
  }

  public getTotal(): number {
    return this.cart?.total || 0;
  }

  destroy(): void {
    window.removeEventListener('cart:updated' as any, this.handleCartUpdate.bind(this));
    super.destroy();
  }
}

/**
 * –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ—Ç –≤–∏–¥–∂–µ—Ç –∫–æ—Ä–∑–∏–Ω—ã
 */
export function init(
  root: HTMLElement,
  opts: CartOptions = {}
): () => void {
  const widget = new ShoppingCartWidget(root, opts);
  return () => widget.destroy();
}

export { ShoppingCartWidget };
export type { CartOptions };
```

## üîß Utility Examples

### Form Validator Utility

**shared/utils/formValidator.ts:**
```typescript
export interface ValidationRule {
  required?: boolean;
  minLength?: number;
  maxLength?: number;
  pattern?: RegExp;
  custom?: (value: string) => boolean;
  message?: string;
}

export interface ValidationRules {
  [fieldName: string]: ValidationRule;
}

export interface ValidationResult {
  isValid: boolean;
  errors: Record<string, string>;
}

export class FormValidator {
  private rules: ValidationRules;

  constructor(rules: ValidationRules) {
    this.rules = rules;
  }

  validate(formData: FormData | Record<string, string>): ValidationResult {
    const errors: Record<string, string> = {};
    const data = formData instanceof FormData
      ? Object.fromEntries(formData.entries())
      : formData;

    for (const [fieldName, rule] of Object.entries(this.rules)) {
      const value = (data[fieldName] as string) || '';
      const error = this.validateField(value, rule);

      if (error) {
        errors[fieldName] = error;
      }
    }

    return {
      isValid: Object.keys(errors).length === 0,
      errors
    };
  }

  private validateField(value: string, rule: ValidationRule): string | null {
    // Required validation
    if (rule.required && !value.trim()) {
      return rule.message || '–≠—Ç–æ –ø–æ–ª–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –¥–ª—è –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è';
    }

    // Skip other validations if field is empty and not required
    if (!value.trim() && !rule.required) {
      return null;
    }

    // Min length validation
    if (rule.minLength && value.length < rule.minLength) {
      return rule.message || `–ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –¥–ª–∏–Ω–∞: ${rule.minLength} —Å–∏–º–≤–æ–ª–æ–≤`;
    }

    // Max length validation
    if (rule.maxLength && value.length > rule.maxLength) {
      return rule.message || `–ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –¥–ª–∏–Ω–∞: ${rule.maxLength} —Å–∏–º–≤–æ–ª–æ–≤`;
    }

    // Pattern validation
    if (rule.pattern && !rule.pattern.test(value)) {
      return rule.message || '–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç';
    }

    // Custom validation
    if (rule.custom && !rule.custom(value)) {
      return rule.message || '–ù–µ–≤–µ—Ä–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ';
    }

    return null;
  }
}

// Preset validation rules
export const validationPresets = {
  email: {
    required: true,
    pattern: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
    message: '–í–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π email'
  },

  phone: {
    required: true,
    pattern: /^\+?[\d\s\-\(\)]+$/,
    message: '–í–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞'
  },

  password: {
    required: true,
    minLength: 8,
    message: '–ü–∞—Ä–æ–ª—å –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å –º–∏–Ω–∏–º—É–º 8 —Å–∏–º–≤–æ–ª–æ–≤'
  },

  name: {
    required: true,
    minLength: 2,
    maxLength: 50,
    message: '–ò–º—è –¥–æ–ª–∂–Ω–æ —Å–æ–¥–µ—Ä–∂–∞—Ç—å –æ—Ç 2 –¥–æ 50 —Å–∏–º–≤–æ–ª–æ–≤'
  }
};

// Helper function
export function createValidator(rules: ValidationRules): FormValidator {
  return new FormValidator(rules);
}
```

### HTTP Request Interceptor

**shared/api/interceptors.ts:**
```typescript
import type { HttpOptions } from './http';

interface RequestInterceptor {
  (config: HttpOptions): HttpOptions | Promise<HttpOptions>;
}

interface ResponseInterceptor {
  (response: any): any;
}

interface ErrorInterceptor {
  (error: any): any;
}

class InterceptorManager {
  private requestInterceptors: RequestInterceptor[] = [];
  private responseInterceptors: ResponseInterceptor[] = [];
  private errorInterceptors: ErrorInterceptor[] = [];

  addRequestInterceptor(interceptor: RequestInterceptor): void {
    this.requestInterceptors.push(interceptor);
  }

  addResponseInterceptor(interceptor: ResponseInterceptor): void {
    this.responseInterceptors.push(interceptor);
  }

  addErrorInterceptor(interceptor: ErrorInterceptor): void {
    this.errorInterceptors.push(interceptor);
  }

  async applyRequestInterceptors(config: HttpOptions): Promise<HttpOptions> {
    let currentConfig = config;

    for (const interceptor of this.requestInterceptors) {
      currentConfig = await interceptor(currentConfig);
    }

    return currentConfig;
  }

  async applyResponseInterceptors(response: any): Promise<any> {
    let currentResponse = response;

    for (const interceptor of this.responseInterceptors) {
      currentResponse = await interceptor(currentResponse);
    }

    return currentResponse;
  }

  async applyErrorInterceptors(error: any): Promise<any> {
    let currentError = error;

    for (const interceptor of this.errorInterceptors) {
      currentError = await interceptor(currentError);
    }

    return currentError;
  }
}

// Global interceptor manager
export const interceptors = new InterceptorManager();

// Common interceptors
interceptors.addRequestInterceptor((config) => {
  // Add auth token
  const token = localStorage.getItem('authToken');
  if (token) {
    config.headers = {
      ...config.headers,
      'Authorization': `Bearer ${token}`
    };
  }

  // Add timestamp
  config.headers = {
    ...config.headers,
    'X-Request-Time': Date.now().toString()
  };

  return config;
});

interceptors.addResponseInterceptor((response) => {
  // Log successful requests
  console.log(`API Response: ${response.status}`, response);

  return response;
});

interceptors.addErrorInterceptor((error) => {
  // Handle common errors
  if (error.status === 401) {
    // Redirect to login
    window.location.href = '/login';
  }

  if (error.status === 403) {
    console.error('Access denied');
  }

  return error;
});
```

## üìù Type Examples

### Complex API Types

**shared/types/complex-api.ts:**
```typescript
// Nested objects
export interface UserProfile {
  id: number;
  personalInfo: {
    firstName: string;
    lastName: string;
    email: string;
    phone?: string;
  };
  preferences: {
    theme: 'light' | 'dark';
    language: string;
    notifications: {
      email: boolean;
      sms: boolean;
      push: boolean;
    };
  };
  addresses: Address[];
}

// Arrays and unions
export interface ProductVariant {
  id: number;
  name: string;
  type: 'color' | 'size' | 'material';
  values: (string | number)[];
  required: boolean;
}

// Generic responses
export interface PaginatedResponse<T> {
  data: T[];
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
  };
  meta?: {
    requestId: string;
    timestamp: string;
  };
}

// Function types
export type ValidatorFunction = (value: any) => boolean;
export type FormatterFunction = (value: any) => string;
export type EventHandler<T = any> = (event: T) => void;

// Mapped types
export type Optional<T> = {
  [P in keyof T]?: T[P];
};

export type Readonly<T> = {
  readonly [P in keyof T]: T[P];
};

// Conditional types
export type ApiMethod = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE';

export type HttpMethodConfig<T extends ApiMethod> =
  T extends 'GET' ? { params?: Record<string, any> } :
  T extends 'POST' | 'PUT' | 'PATCH' ? { data: any } :
  {};

// Utility types for forms
export type FormFieldValue = string | number | boolean | Date | null;

export interface FormField {
  name: string;
  type: 'text' | 'email' | 'password' | 'number' | 'date' | 'checkbox' | 'select';
  value: FormFieldValue;
  required?: boolean;
  validation?: ValidationRule[];
}

export interface FormData {
  [fieldName: string]: FormFieldValue;
}

// Event system types
export interface BaseEvent<T = any> {
  type: string;
  timestamp: Date;
  payload: T;
}

export interface UserActionEvent extends BaseEvent {
  type: 'user_action';
  payload: {
    action: string;
    target: string;
    metadata?: Record<string, any>;
  };
}

export interface SystemEvent extends BaseEvent {
  type: 'system';
  payload: {
    component: string;
    message: string;
    level: 'info' | 'warn' | 'error';
  };
}

// Configuration types
export interface AppConfig {
  api: {
    baseUrl: string;
    timeout: number;
    retries: number;
  };
  ui: {
    theme: 'light' | 'dark';
    animations: boolean;
    language: string;
  };
  features: {
    reviews: boolean;
    wishlist: boolean;
    notifications: boolean;
  };
}
```

